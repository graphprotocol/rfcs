<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>RFC-0001: Subgraph Composition - Graph Protocol RFCs and Engineering Plans</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        
        <link rel="stylesheet" href="../assets/mermaid.css">
        
        <link rel="stylesheet" href="../assets/custom.css">
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="../rfcs/index.html"><strong aria-hidden="true">2.</strong> RFCs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rfcs/approved.html"><strong aria-hidden="true">2.1.</strong> Approved RFCs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../rfcs/0001-subgraph-composition.html" class="active"><strong aria-hidden="true">2.1.1.</strong> RFC-0001: Subgraph Composition</a></li><li class="chapter-item expanded "><a href="../rfcs/0002-ethereum-tracing-cache.html"><strong aria-hidden="true">2.1.2.</strong> RFC-0002: Ethereum Tracing Cache</a></li><li class="chapter-item expanded "><a href="../rfcs/0003-mutations.html"><strong aria-hidden="true">2.1.3.</strong> RFC-0003: Mutations</a></li><li class="chapter-item expanded "><a href="../rfcs/0004-fulltext-search.html"><strong aria-hidden="true">2.1.4.</strong> RFC-0004: Fulltext Search</a></li></ol></li><li class="chapter-item expanded "><a href="../rfcs/obsolete.html"><strong aria-hidden="true">2.2.</strong> Obsolete RFCs</a></li><li class="chapter-item expanded "><a href="../rfcs/rejected.html"><strong aria-hidden="true">2.3.</strong> Rejected RFCs</a></li></ol></li><li class="chapter-item expanded "><a href="../engineering-plans/index.html"><strong aria-hidden="true">3.</strong> Engineering Plans</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../engineering-plans/approved.html"><strong aria-hidden="true">3.1.</strong> Approved Plans</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../engineering-plans/0001-graphql-query-prefetching.html"><strong aria-hidden="true">3.1.1.</strong> PLAN-0001: GraphQL Query Prefetching</a></li><li class="chapter-item expanded "><a href="../engineering-plans/0002-ethereum-tracing-cache.html"><strong aria-hidden="true">3.1.2.</strong> PLAN-0002: Ethereum Tracing Cache</a></li><li class="chapter-item expanded "><a href="../engineering-plans/0003-remove-jsonb-storage.html"><strong aria-hidden="true">3.1.3.</strong> PLAN-0003: Remove JSONB Storage</a></li></ol></li><li class="chapter-item expanded "><a href="../engineering-plans/obsolete.html"><strong aria-hidden="true">3.2.</strong> Obsolete Plans</a></li><li class="chapter-item expanded "><a href="../engineering-plans/rejected.html"><strong aria-hidden="true">3.3.</strong> Rejected Plans</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Graph Protocol RFCs and Engineering Plans</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#rfc-0001-subgraph-composition" id="rfc-0001-subgraph-composition">RFC-0001: Subgraph Composition</a></h1>
<dl>
  <dt>Author</dt>
  <dd>Jannis Pohlmann</dd>
<dt>RFC pull request</dt>
  <dd><a href="https://github.com/graphprotocol/rfcs/pull/1">https://github.com/graphprotocol/rfcs/pull/1</a></dd>
<dt>Obsoletes</dt>
  <dd>-</dd>
<dt>Date of submission</dt>
  <dd>2019-12-08</dd>
<dt>Date of approval</dt>
  <dd>-</dd>
<dt>Approved by</dt>
  <dd>-</dd>
</dl>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>Subgraph composition enables referencing, extending and querying entities across
subgraph boundaries.</p>
<h2><a class="header" href="#goals--motivation" id="goals--motivation">Goals &amp; Motivation</a></h2>
<p>The high-level goal of subgraph composition is to be able to compose subgraph
schemas and data hierarchically. Imagine umbrella subgraphs that combine all the
data from a domain (e.g. DeFi, job markets, music) through one unified, coherent
API. This could allow reuse and governance at different levels and go all the
way to the top, fulfilling the vision of <em>the</em> Graph.</p>
<p>The ability to reference, extend and query entities across subgraph boundaries
enables several use cases:</p>
<ol>
<li>Linking entities across subgraphs.</li>
<li>Extending entities defined in other subgraphs by adding new fields.</li>
<li>Breaking down data silos by composing subgraphs and defining richer schemas
without indexing the same data over and over again.</li>
</ol>
<p>Subgraph composition is needed to avoid duplicated work, both in terms of
developing subgraphs as well as indexing them. It is an essential part of the
overall vision behind The Graph, as it allows to combine isolated subgraphs into
a complete, connected graph of the (decentralized) world's data.</p>
<p>Subgraph developers will benefit from the ability to reference data from other
subgraphs, saving them development time and enabling richer data models. dApp
developers will be able to leverage this to build more compelling applications.
Node operators will benefit from subgraph composition by having better insight
into which subgraphs are queried together, allowing them to make more informed
decisions about which subgraphs to index.</p>
<h2><a class="header" href="#urgency" id="urgency">Urgency</a></h2>
<p>Due to the high impact of this feature and its important role in fulfilling the
vision behind The Graph, it would be good to start working on this as early as
possible.</p>
<h2><a class="header" href="#terminology" id="terminology">Terminology</a></h2>
<p>The feature is referred to by <em>query-time subgraph composition</em>, short:
<em>subgraph composition</em>. </p>
<p>Terms introduced and used in this RFC:</p>
<ul>
<li><em>Imported schema</em>: The schema of another subgraph from which types are
imported.</li>
<li><em>Imported type</em>: An entity type imported from another subgraph schema.</li>
<li><em>Extended type</em>: An entity type imported from another subgraph schema and
extended in the subgraph that imports it.</li>
<li><em>Local schema</em>: The schema of the subgraph that imports from another subgraph.</li>
<li><em>Local type</em>: A type defined in the local schema.</li>
</ul>
<h2><a class="header" href="#detailed-design" id="detailed-design">Detailed Design</a></h2>
<p>The sections below make the assumption that there is a subgraph with the name
<code>ethereum/mainnet</code> that includes an <code>Address</code> entity type.</p>
<h3><a class="header" href="#composing-subgraphs-by-importing-types" id="composing-subgraphs-by-importing-types">Composing Subgraphs By Importing Types</a></h3>
<p>In order to reference entity types from annother subgraph, a developer would
first import these types from the other subgraph's schema.</p>
<p>Types can be imported either from a subgraph name or from a subgraph ID.
Importing from a subgraph name means that the exact version of the imported
subgraph will be identified at query time and its schema may change in arbitrary
ways over time. Importing from a subgraph ID guarantees that the schema will
never change but also means that the import points to a subgraph version that
may become outdated over time.</p>
<p>Let's say a DAO subgraph contains a <code>Proposal</code> type that has a <code>proposer</code> field
that should link to an Ethereum address (think: Ethereum accounts or contracts)
and a <code>transaction</code> field that should link to an Ethereum transaction. The
developer would then write the DAO subgraph schema as follows:</p>
<pre><code class="language-graphql">type _Schema_
  @import(
    types: [&quot;Address&quot;, { name: &quot;Transaction&quot;, as: &quot;EthereumTransaction&quot; }],
    from: { name: &quot;ethereum/mainnet&quot; }
  )

type Proposal @entity {
  id: ID!
  proposer: Address!
  transaction: EthereumTransaction!
}
</code></pre>
<p>This would then allow queries that follow the references to addresses and
transactions, like</p>
<pre><code class="language-graphql">{
  proposals { 
    proposer {
      balance
      address
    }
    transaction {
      hash
      block {
        number
      }
    }
  }
}
</code></pre>
<h3><a class="header" href="#extending-types-from-imported-schemas" id="extending-types-from-imported-schemas">Extending Types From Imported Schemas</a></h3>
<p>Extending types from another subgraph involves several steps:</p>
<ol>
<li>Importing the entity types from the other subgraph.</li>
<li>Extending these types with custom fields.</li>
<li>Managing (e.g. creating) extended entities in subgraph mappings.</li>
</ol>
<p>Let's say the DAO subgraph wants to extend the Ethereum <code>Address</code> type to
include the proposals created by each respective account. To achieve this, the
developer would write the following schema:</p>
<pre><code class="language-graphql">type _Schema_
  @import(
    types: [&quot;Address&quot;],
    from: { name: &quot;ethereum/mainnet&quot; }
  )

type Proposal @entity {
  id: ID!
  proposer: Address!
}

extend type Address {
  proposals: [Proposal!]! @derivedFrom(field: &quot;proposal&quot;)
}
</code></pre>
<p>This makes queries like the following possible, where the query can go &quot;back&quot;
from addresses to proposal entities, despite the Ethereum <code>Address</code> type
originally being defined in the <code>ethereum/mainnet</code> subgraph.</p>
<pre><code class="language-graphql">{
  addresses {
    id
    proposals {
      id
      proposer {
        id
    }
  }
}
</code></pre>
<p>In the above case, the <code>proposals</code> field on the extended type is derived, which
means that an implementation wouldn't have to create a local extension type in
the store. However, if <code>proposals</code> was defined as</p>
<pre><code class="language-graphql">extend type Address {
  proposals: [Proposal!]!
}
</code></pre>
<p>then it would the subgraph mappings would have to create partial <code>Address</code>
entities with <code>id</code> and <code>proposals</code> fields for all addresses from which proposals
were created. At query time, these entity instances would have to be merged with
the original <code>Address</code> entities from the <code>ethereum/mainnet</code> subgraph.</p>
<h3><a class="header" href="#subgraph-availability" id="subgraph-availability">Subgraph Availability</a></h3>
<p>In the decentralized network, queries will be split and routed through the
network based on what indexers are available and which subgraphs they index. At
that point, failure to find an indexer for a subgraph that types were imported
from will result in a query error. The error that a non-nullable field resolved
to null bubbles up to the next nullable parent, in accordance with the <a href="https://graphql.github.io/graphql-spec/draft/#sec-Errors.Error-result-format">GraphQL
Spec</a>.</p>
<p>Until the network is reality, we are dealing with individual Graph Nodes and
querying subgraphs where imported entity types are not also indexed on the same
node should be handled with more tolerance. This RFC proposes that entity
reference fields that refer to imported types are converted to being optional in
the generated API schema. If the subgraph that the type is imported from is not
available on a node, such fields should resolve to <code>null</code>.</p>
<h3><a class="header" href="#interfaces" id="interfaces">Interfaces</a></h3>
<p>Subgraph composition also supports interfaces in the ways outlined below.</p>
<h4><a class="header" href="#interfaces-can-be-imported-from-other-subgraphs" id="interfaces-can-be-imported-from-other-subgraphs">Interfaces Can Be Imported From Other Subgraphs</a></h4>
<p>The syntax for this is the same as that for importing types:</p>
<pre><code class="language-graphql">type _Schema_
  @import(types: [&quot;ERC20&quot;], from: { name: &quot;graphprotocol/erc20&quot; })
</code></pre>
<h4><a class="header" href="#local-types-can-implement-imported-interfaces" id="local-types-can-implement-imported-interfaces">Local Types Can Implement Imported Interfaces</a></h4>
<p>This is achieved by importing the interface from another subgraph schema
and implementing it in entity types:</p>
<pre><code class="language-graphql">type _Schema_
  @import(types: [&quot;ERC20&quot;], from: { name: &quot;graphprotocol/erc20&quot; })

type MyToken implements ERC20 @entity {
  # ...
}
</code></pre>
<h4><a class="header" href="#imported-types-can-be-extended-to-implement-local-interfaces" id="imported-types-can-be-extended-to-implement-local-interfaces">Imported Types Can Be Extended To Implement Local Interfaces</a></h4>
<p>This is achieved by importing the types from another subgraph schema, defining a
local interface and using <code>extend</code> to implement the interface on the imported
types:</p>
<pre><code class="language-graphql">type _Schema_
  @import(types: [{ name: &quot;Token&quot;, as &quot;LPT&quot; }], from: { name: &quot;livepeer/livepeer&quot; })
  @import(types: [{ name: &quot;Token&quot;, as &quot;Rep&quot; }], from: { name: &quot;augur/augur&quot; })

interface Token {
  id: ID!
  balance: BigInt!
}

extend LPT implements Token {
  # ...
}
extend Rep implements Token {
  # ...
}
</code></pre>
<h4><a class="header" href="#imported-types-can-be-extended-to-implement-imported-interfaces" id="imported-types-can-be-extended-to-implement-imported-interfaces">Imported Types Can Be Extended To Implement Imported Interfaces</a></h4>
<p>This is a combination of importing an interface, importing the types and
extending them to implement the interface:</p>
<pre><code class="language-graphql">type _Schema_
  @import(types: [&quot;Token&quot;], from: { name: &quot;graphprotocol/token&quot; })
  @import(types: [{ name: &quot;Token&quot;, as &quot;LPT&quot; }], from: { name: &quot;livepeer/livepeer&quot; })
  @import(types: [{ name: &quot;Token&quot;, as &quot;Rep&quot; }], from: { name: &quot;augur/augur&quot; })

extend LPT implements Token {
  # ...
}
extend Rep implements Token {
  # ...
}
</code></pre>
<h4><a class="header" href="#implementation-concerns-for-interface-support" id="implementation-concerns-for-interface-support">Implementation Concerns For Interface Support</a></h4>
<p>Querying across types from different subgraphs that implement the same interface
may require a smart algorithm, especially when it comes to pagination. For
instance, if the first 1000 entities for an interface are queried, this range of
1000 entities may be divided up between different local and imported types
arbitrarily.</p>
<p>A naive algorithm could request 1000 entities from each subgraph, applying the
selected filters and order, combine the results and cut off everything after the
first 1000 items. This would generate a minimum of requests but would involve
significant overfetching.</p>
<p>Another algorithm could just fetch the first item from each subgraph, then based
on that information, divide up the range in more optimal ways than the previous
algorith, and satisfy the query with more requests but with less overfetching.</p>
<h2><a class="header" href="#compatibility" id="compatibility">Compatibility</a></h2>
<p>Subgraph composition is a purely additive, non-breaking change. Existing
subgraphs remain valid without any migrations being necessary.</p>
<h2><a class="header" href="#drawbacks-and-risks" id="drawbacks-and-risks">Drawbacks And Risks</a></h2>
<p>Reasons that could speak against implementing this feature:</p>
<ul>
<li>
<p>Schema parsing and validation becomes more complicated. Especially validation
of imported schemas may not always be possible, depending on whether and when
the referenced subgraph is available on the Graph Node or not.</p>
</li>
<li>
<p>Query execution becomes more complicated. The subgraph a type belongs to must
be identified and local as well as imported versions of extended entities have
to be queried separately and be merged before returning data to the client.</p>
</li>
</ul>
<h2><a class="header" href="#alternatives" id="alternatives">Alternatives</a></h2>
<p>No alternatives have been considered.</p>
<p>There are other ways to compose subgraph schemas using GraphQL technologies such
as <a href="https://www.apollographql.com/docs/graphql-tools/schema-stitching/">schema
stitching</a>
or <a href="https://www.apollographql.com/docs/apollo-server/federation/introduction/">Apollo
Federation</a>.
However, schema stitching is being deprecated and Apollo Federation requires a
centralized server to serve to extend and merge GraphQL API. Both of these
solutions slow down queries.</p>
<p>Another reason not to use these is that GraphQL will only be <em>one</em> of several
query languages supported in the future. Composition therefore has to be
implemented in a query-language-agnostic way.</p>
<h2><a class="header" href="#open-questions" id="open-questions">Open Questions</a></h2>
<ul>
<li>
<p>Right now, interfaces require unique IDs across all the concrete entity types
that implement them. This is not something we can guarantee any longer if
these concrete types live in different subgraphs. So we have to handle this at
query time (or must somehow disallow it, returning a query error).</p>
<p>It is also unclear how an individual interface entity lookup would look like
if IDs are no longer guaranteed to be unique:</p>
<pre><code class="language-graphql">someInterface(id: &quot;?????&quot;) {
}
</code></pre>
</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../rfcs/approved.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../rfcs/0002-ethereum-tracing-cache.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="../rfcs/approved.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="../rfcs/0002-ethereum-tracing-cache.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        
        <script type="text/javascript" src="../assets/mermaid.min.js"></script>
        
        <script type="text/javascript" src="../assets/mermaid-init.js"></script>
        

        

    </body>
</html>
